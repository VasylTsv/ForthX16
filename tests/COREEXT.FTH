\ TO TEST THE ANS FORTH CORE EXTENSION WORD SET\ THIS PROGRAM WAS WRITTEN BY GERRY JACKSON IN 2006, WITH CONTRIBUTIONS FROM\ OTHERS WHERE INDICATED, AND IS IN THE PUBLIC DOMAIN - IT CAN BE DISTRIBUTED\ AND/OR MODIFIED IN ANY WAY BUT PLEASE RETAIN THIS NOTICE.\ THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL,\ BUT WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF\ MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.\ THE TESTS ARE NOT CLAIMED TO BE COMPREHENSIVE OR CORRECT \ ------------------------------------------------------------------------------\ VERSION 0.13 28 OCTOBER 2015\              REPLACE <FALSE> AND <TRUE> WITH FALSE AND TRUE TO AVOID\              DEPENDENCE ON CORE TESTS\              MOVED SAVE-INPUT AND RESTORE-INPUT TESTS IN A FILE TO FILETEST.FTH\              USE OF 2VARIABLE (FROM OPTIONAL WORDSET) REPLACED WITH CREATE.\              MINOR LOWER TO UPPER CASE CONVERSIONS.\              CALLS TO COMPARE REPLACED BY S= (IN UTILITIES.FTH) TO AVOID USE\              OF A WORD FROM AN OPTIONAL WORD SET.\              UNUSED TESTS REVISED AS UNUSED UNUSED = MAY RETURN FALSE WHEN AN\              IMPLEMENTATION HAS THE DATA STACK SHARING UNUSED DATASPACE.\              DOUBLE NUMBER INPUT DEPENDENCY REMOVED FROM THE HOLDS TESTS.\              MINOR CASE SENSITIVITIES REMOVED IN DEFINITION NAMES.\         0.11 25 APRIL 2015\              ADDED TESTS FOR PARSE-NAME HOLDS BUFFER:\              S\" TESTS ADDED\              DEFER IS ACTION-OF DEFER! DEFER@ TESTS ADDED\              EMPTY CASE STATEMENT TEST ADDED\              [COMPILE] TESTS REMOVED BECAUSE IT IS OBSOLESCENT IN FORTH 2012\         0.10 1 AUGUST 2014\             ADDED TESTS CONTRIBUTED BY JAMES BOWMAN FOR:\                <> U> 0<> 0> NIP TUCK ROLL PICK 2>R 2R@ 2R>\                HEX WITHIN UNUSED AGAIN MARKER\             ADDED TESTS FOR:\                .R U.R ERASE PAD REFILL SOURCE-ID \             REMOVED ABORT FROM NEVEREXECUTED TO ENABLE WIN32\             TO CONTINUE AFTER FAILURE OF RESTORE-INPUT.\             REMOVED MAX-INTX WHICH IS NO LONGER USED.\         0.7 6 JUNE 2012 EXTRA CASE TEST ADDED\         0.6 1 APRIL 2012 TESTS PLACED IN THE PUBLIC DOMAIN.\             SAVE-INPUT & RESTORE-INPUT TESTS, POSITION\             OF T{ MOVED SO THAT TESTS WORK WITH TTESTER.FS\             CONVERT TEST DELETED - OBSOLETE WORD REMOVED FROM FORTH 200X\             IMMEDIATE VALUES TESTED\             RECURSE WITH :NONAME TESTED\             PARSE AND .( TESTED\             PARSING BEHAVIOUR OF C" ADDED\         0.5 14 SEPTEMBER 2011 REMOVED THE DOUBLE [ELSE] FROM THE\             INITIAL SAVE-INPUT & RESTORE-INPUT TEST\         0.4 30 NOVEMBER 2009  MAX-INT REPLACED WITH MAX-INTX TO\             AVOID REDEFINITION WARNINGS.\         0.3  6 MARCH 2009 { AND } REPLACED WITH T{ AND }T\                           CONVERT TEST NOW INDEPENDENT OF CELL SIZE\         0.2  20 APRIL 2007 ANS FORTH WORDS CHANGED TO UPPER CASE\                            TESTS QD3 TO QD6 BY REINHOLD STRAUB\         0.1  OCT 2006 FIRST VERSION RELEASED\ -----------------------------------------------------------------------------\ THE TESTS ARE BASED ON JOHN HAYES TEST PROGRAM FOR THE CORE WORD SET\ WORDS TESTED IN THIS FILE ARE:\     .( .R 0<> 0> 2>R 2R> 2R@ :NONAME <> ?DO AGAIN C" CASE COMPILE, ENDCASE\     ENDOF ERASE FALSE HEX MARKER NIP OF PAD PARSE PICK REFILL\     RESTORE-INPUT ROLL SAVE-INPUT SOURCE-ID TO TRUE TUCK U.R U> UNUSED\     VALUE WITHIN [COMPILE]\ WORDS NOT TESTED OR PARTIALLY TESTED:\     \ BECAUSE IT HAS BEEN EXTENSIVELY USED ALREADY AND IS, HENCE, UNNECESSARY\     REFILL AND SOURCE-ID FROM THE USER INPUT DEVICE WHICH ARE NOT POSSIBLE\     WHEN TESTING FROM A FILE SUCH AS THIS ONE\     UNUSED (PARTIALLY TESTED) AS THE VALUE RETURNED IS SYSTEM DEPENDENT\     OBSOLESCENT WORDS #TIB CONVERT EXPECT QUERY SPAN TIB AS THEY HAVE BEEN\     REMOVED FROM THE FORTH 2012 STANDARD\ RESULTS FROM WORDS THAT OUTPUT TO THE USER OUTPUT DEVICE HAVE TO VISUALLY\ CHECKED FOR CORRECTNESS. THESE ARE .R U.R .(\ -----------------------------------------------------------------------------\ ASSUMPTIONS & DEPENDENCIES:\     - TESTER.FR (OR TTESTER.FS), ERRORREPORT.FTH AND UTILITIES.FTH HAVE BEEN\       INCLUDED PRIOR TO THIS FILE\     - THE CORE WORD SET AVAILABLE\ -----------------------------------------------------------------------------TESTING CORE EXTENSION WORDSDECIMALTESTING TRUE FALSET{ TRUE  -> 0 INVERT }TT{ FALSE -> 0 }T\ -----------------------------------------------------------------------------TESTING <> U>   (CONTRIBUTED BY JAMES BOWMAN)T{ 0 0 <> -> FALSE }TT{ 1 1 <> -> FALSE }TT{ -1 -1 <> -> FALSE }TT{ 1 0 <> -> TRUE }TT{ -1 0 <> -> TRUE }TT{ 0 1 <> -> TRUE }TT{ 0 -1 <> -> TRUE }TT{ 0 1 U> -> FALSE }TT{ 1 2 U> -> FALSE }TT{ 0 MID-UINT U> -> FALSE }TT{ 0 MAX-UINT U> -> FALSE }TT{ MID-UINT MAX-UINT U> -> FALSE }TT{ 0 0 U> -> FALSE }TT{ 1 1 U> -> FALSE }TT{ 1 0 U> -> TRUE }TT{ 2 1 U> -> TRUE }TT{ MID-UINT 0 U> -> TRUE }TT{ MAX-UINT 0 U> -> TRUE }TT{ MAX-UINT MID-UINT U> -> TRUE }T\ -----------------------------------------------------------------------------TESTING 0<> 0>   (CONTRIBUTED BY JAMES BOWMAN)T{ 0 0<> -> FALSE }TT{ 1 0<> -> TRUE }TT{ 2 0<> -> TRUE }TT{ -1 0<> -> TRUE }TT{ MAX-UINT 0<> -> TRUE }TT{ MIN-INT 0<> -> TRUE }TT{ MAX-INT 0<> -> TRUE }TT{ 0 0> -> FALSE }TT{ -1 0> -> FALSE }TT{ MIN-INT 0> -> FALSE }TT{ 1 0> -> TRUE }TT{ MAX-INT 0> -> TRUE }T\ -----------------------------------------------------------------------------TESTING NIP TUCK ROLL PICK   (CONTRIBUTED BY JAMES BOWMAN)T{ 1 2 NIP -> 2 }TT{ 1 2 3 NIP -> 1 3 }TT{ 1 2 TUCK -> 2 1 2 }TT{ 1 2 3 TUCK -> 1 3 2 3 }TT{ : RO5 100 200 300 400 500 ; -> }TT{ RO5 3 ROLL -> 100 300 400 500 200 }TT{ RO5 2 ROLL -> RO5 ROT }TT{ RO5 1 ROLL -> RO5 SWAP }TT{ RO5 0 ROLL -> RO5 }TT{ RO5 2 PICK -> 100 200 300 400 500 300 }TT{ RO5 1 PICK -> RO5 OVER }TT{ RO5 0 PICK -> RO5 DUP }T\ -----------------------------------------------------------------------------TESTING 2>R 2R@ 2R>   (CONTRIBUTED BY JAMES BOWMAN)T{ : RR0 2>R 100 R> R> ; -> }TT{ 300 400 RR0 -> 100 400 300 }TT{ 200 300 400 RR0 -> 200 100 400 300 }TT{ : RR1 2>R 100 2R@ R> R> ; -> }TT{ 300 400 RR1 -> 100 300 400 400 300 }TT{ 200 300 400 RR1 -> 200 100 300 400 400 300 }TT{ : RR2 2>R 100 2R> ; -> }TT{ 300 400 RR2 -> 100 300 400 }TT{ 200 300 400 RR2 -> 200 100 300 400 }T\ -----------------------------------------------------------------------------TESTING HEX   (CONTRIBUTED BY JAMES BOWMAN)T{ BASE @ HEX BASE @ DECIMAL BASE @ - SWAP BASE ! -> 6 }T\ -----------------------------------------------------------------------------TESTING WITHIN   (CONTRIBUTED BY JAMES BOWMAN)T{ 0 0 0 WITHIN -> FALSE }TT{ 0 0 MID-UINT WITHIN -> TRUE }TT{ 0 0 MID-UINT+1 WITHIN -> TRUE }TT{ 0 0 MAX-UINT WITHIN -> TRUE }TT{ 0 MID-UINT 0 WITHIN -> FALSE }TT{ 0 MID-UINT MID-UINT WITHIN -> FALSE }TT{ 0 MID-UINT MID-UINT+1 WITHIN -> FALSE }TT{ 0 MID-UINT MAX-UINT WITHIN -> FALSE }TT{ 0 MID-UINT+1 0 WITHIN -> FALSE }TT{ 0 MID-UINT+1 MID-UINT WITHIN -> TRUE }TT{ 0 MID-UINT+1 MID-UINT+1 WITHIN -> FALSE }TT{ 0 MID-UINT+1 MAX-UINT WITHIN -> FALSE }TT{ 0 MAX-UINT 0 WITHIN -> FALSE }TT{ 0 MAX-UINT MID-UINT WITHIN -> TRUE }TT{ 0 MAX-UINT MID-UINT+1 WITHIN -> TRUE }TT{ 0 MAX-UINT MAX-UINT WITHIN -> FALSE }TT{ MID-UINT 0 0 WITHIN -> FALSE }TT{ MID-UINT 0 MID-UINT WITHIN -> FALSE }TT{ MID-UINT 0 MID-UINT+1 WITHIN -> TRUE }TT{ MID-UINT 0 MAX-UINT WITHIN -> TRUE }TT{ MID-UINT MID-UINT 0 WITHIN -> TRUE }TT{ MID-UINT MID-UINT MID-UINT WITHIN -> FALSE }TT{ MID-UINT MID-UINT MID-UINT+1 WITHIN -> TRUE }TT{ MID-UINT MID-UINT MAX-UINT WITHIN -> TRUE }TT{ MID-UINT MID-UINT+1 0 WITHIN -> FALSE }TT{ MID-UINT MID-UINT+1 MID-UINT WITHIN -> FALSE }TT{ MID-UINT MID-UINT+1 MID-UINT+1 WITHIN -> FALSE }TT{ MID-UINT MID-UINT+1 MAX-UINT WITHIN -> FALSE }TT{ MID-UINT MAX-UINT 0 WITHIN -> FALSE }TT{ MID-UINT MAX-UINT MID-UINT WITHIN -> FALSE }TT{ MID-UINT MAX-UINT MID-UINT+1 WITHIN -> TRUE }TT{ MID-UINT MAX-UINT MAX-UINT WITHIN -> FALSE }TT{ MID-UINT+1 0 0 WITHIN -> FALSE }TT{ MID-UINT+1 0 MID-UINT WITHIN -> FALSE }TT{ MID-UINT+1 0 MID-UINT+1 WITHIN -> FALSE }TT{ MID-UINT+1 0 MAX-UINT WITHIN -> TRUE }TT{ MID-UINT+1 MID-UINT 0 WITHIN -> TRUE }TT{ MID-UINT+1 MID-UINT MID-UINT WITHIN -> FALSE }TT{ MID-UINT+1 MID-UINT MID-UINT+1 WITHIN -> FALSE }TT{ MID-UINT+1 MID-UINT MAX-UINT WITHIN -> TRUE }TT{ MID-UINT+1 MID-UINT+1 0 WITHIN -> TRUE }TT{ MID-UINT+1 MID-UINT+1 MID-UINT WITHIN -> TRUE }TT{ MID-UINT+1 MID-UINT+1 MID-UINT+1 WITHIN -> FALSE }TT{ MID-UINT+1 MID-UINT+1 MAX-UINT WITHIN -> TRUE }TT{ MID-UINT+1 MAX-UINT 0 WITHIN -> FALSE }TT{ MID-UINT+1 MAX-UINT MID-UINT WITHIN -> FALSE }TT{ MID-UINT+1 MAX-UINT MID-UINT+1 WITHIN -> FALSE }TT{ MID-UINT+1 MAX-UINT MAX-UINT WITHIN -> FALSE }TT{ MAX-UINT 0 0 WITHIN -> FALSE }TT{ MAX-UINT 0 MID-UINT WITHIN -> FALSE }TT{ MAX-UINT 0 MID-UINT+1 WITHIN -> FALSE }TT{ MAX-UINT 0 MAX-UINT WITHIN -> FALSE }TT{ MAX-UINT MID-UINT 0 WITHIN -> TRUE }TT{ MAX-UINT MID-UINT MID-UINT WITHIN -> FALSE }TT{ MAX-UINT MID-UINT MID-UINT+1 WITHIN -> FALSE }TT{ MAX-UINT MID-UINT MAX-UINT WITHIN -> FALSE }TT{ MAX-UINT MID-UINT+1 0 WITHIN -> TRUE }TT{ MAX-UINT MID-UINT+1 MID-UINT WITHIN -> TRUE }TT{ MAX-UINT MID-UINT+1 MID-UINT+1 WITHIN -> FALSE }TT{ MAX-UINT MID-UINT+1 MAX-UINT WITHIN -> FALSE }TT{ MAX-UINT MAX-UINT 0 WITHIN -> TRUE }TT{ MAX-UINT MAX-UINT MID-UINT WITHIN -> TRUE }TT{ MAX-UINT MAX-UINT MID-UINT+1 WITHIN -> TRUE }TT{ MAX-UINT MAX-UINT MAX-UINT WITHIN -> FALSE }TT{ MIN-INT MIN-INT MIN-INT WITHIN -> FALSE }TT{ MIN-INT MIN-INT 0 WITHIN -> TRUE }TT{ MIN-INT MIN-INT 1 WITHIN -> TRUE }TT{ MIN-INT MIN-INT MAX-INT WITHIN -> TRUE }TT{ MIN-INT 0 MIN-INT WITHIN -> FALSE }TT{ MIN-INT 0 0 WITHIN -> FALSE }TT{ MIN-INT 0 1 WITHIN -> FALSE }TT{ MIN-INT 0 MAX-INT WITHIN -> FALSE }TT{ MIN-INT 1 MIN-INT WITHIN -> FALSE }TT{ MIN-INT 1 0 WITHIN -> TRUE }TT{ MIN-INT 1 1 WITHIN -> FALSE }TT{ MIN-INT 1 MAX-INT WITHIN -> FALSE }TT{ MIN-INT MAX-INT MIN-INT WITHIN -> FALSE }TT{ MIN-INT MAX-INT 0 WITHIN -> TRUE }TT{ MIN-INT MAX-INT 1 WITHIN -> TRUE }TT{ MIN-INT MAX-INT MAX-INT WITHIN -> FALSE }TT{ 0 MIN-INT MIN-INT WITHIN -> FALSE }TT{ 0 MIN-INT 0 WITHIN -> FALSE }TT{ 0 MIN-INT 1 WITHIN -> TRUE }TT{ 0 MIN-INT MAX-INT WITHIN -> TRUE }TT{ 0 0 MIN-INT WITHIN -> TRUE }TT{ 0 0 0 WITHIN -> FALSE }TT{ 0 0 1 WITHIN -> TRUE }TT{ 0 0 MAX-INT WITHIN -> TRUE }TT{ 0 1 MIN-INT WITHIN -> FALSE }TT{ 0 1 0 WITHIN -> FALSE }TT{ 0 1 1 WITHIN -> FALSE }TT{ 0 1 MAX-INT WITHIN -> FALSE }TT{ 0 MAX-INT MIN-INT WITHIN -> FALSE }TT{ 0 MAX-INT 0 WITHIN -> FALSE }TT{ 0 MAX-INT 1 WITHIN -> TRUE }TT{ 0 MAX-INT MAX-INT WITHIN -> FALSE }TT{ 1 MIN-INT MIN-INT WITHIN -> FALSE }TT{ 1 MIN-INT 0 WITHIN -> FALSE }TT{ 1 MIN-INT 1 WITHIN -> FALSE }TT{ 1 MIN-INT MAX-INT WITHIN -> TRUE }TT{ 1 0 MIN-INT WITHIN -> TRUE }TT{ 1 0 0 WITHIN -> FALSE }TT{ 1 0 1 WITHIN -> FALSE }TT{ 1 0 MAX-INT WITHIN -> TRUE }TT{ 1 1 MIN-INT WITHIN -> TRUE }TT{ 1 1 0 WITHIN -> TRUE }TT{ 1 1 1 WITHIN -> FALSE }TT{ 1 1 MAX-INT WITHIN -> TRUE }TT{ 1 MAX-INT MIN-INT WITHIN -> FALSE }TT{ 1 MAX-INT 0 WITHIN -> FALSE }TT{ 1 MAX-INT 1 WITHIN -> FALSE }TT{ 1 MAX-INT MAX-INT WITHIN -> FALSE }TT{ MAX-INT MIN-INT MIN-INT WITHIN -> FALSE }TT{ MAX-INT MIN-INT 0 WITHIN -> FALSE }TT{ MAX-INT MIN-INT 1 WITHIN -> FALSE }TT{ MAX-INT MIN-INT MAX-INT WITHIN -> FALSE }TT{ MAX-INT 0 MIN-INT WITHIN -> TRUE }TT{ MAX-INT 0 0 WITHIN -> FALSE }TT{ MAX-INT 0 1 WITHIN -> FALSE }TT{ MAX-INT 0 MAX-INT WITHIN -> FALSE }TT{ MAX-INT 1 MIN-INT WITHIN -> TRUE }TT{ MAX-INT 1 0 WITHIN -> TRUE }TT{ MAX-INT 1 1 WITHIN -> FALSE }TT{ MAX-INT 1 MAX-INT WITHIN -> FALSE }TT{ MAX-INT MAX-INT MIN-INT WITHIN -> TRUE }TT{ MAX-INT MAX-INT 0 WITHIN -> TRUE }TT{ MAX-INT MAX-INT 1 WITHIN -> TRUE }TT{ MAX-INT MAX-INT MAX-INT WITHIN -> FALSE }T\ -----------------------------------------------------------------------------TESTING UNUSED  (CONTRIBUTED BY JAMES BOWMAN & PETER KNAGGS)VARIABLE UNUSED0T{ UNUSED DROP -> }T                  T{ ALIGN UNUSED UNUSED0 ! 0 , UNUSED CELL+ UNUSED0 @ = -> TRUE }TT{ UNUSED UNUSED0 ! 0 C, UNUSED CHAR+ UNUSED0 @ =         -> TRUE }T  \ ALIGNED -> UNALIGNEDT{ UNUSED UNUSED0 ! 0 C, UNUSED CHAR+ UNUSED0 @ = -> TRUE }T  \ UNALIGNED -> ?\ -----------------------------------------------------------------------------TESTING AGAIN   (CONTRIBUTED BY JAMES BOWMAN)T{ : AG0 701 BEGIN DUP 7 MOD 0= IF EXIT THEN 1+ AGAIN ; -> }TT{ AG0 -> 707 }T\ -----------------------------------------------------------------------------TESTING MARKER   (CONTRIBUTED BY JAMES BOWMAN)T{ : MA? BL WORD FIND NIP 0<> ; -> }TT{ MARKER MA0 -> }TT{ : MA1 111 ; -> }TT{ MARKER MA2 -> }TT{ : MA1 222 ; -> }TT{ MA? MA0 MA? MA1 MA? MA2 -> TRUE TRUE TRUE }TT{ MA1 MA2 MA1 -> 222 111 }TT{ MA? MA0 MA? MA1 MA? MA2 -> TRUE TRUE FALSE }TT{ MA0 -> }TT{ MA? MA0 MA? MA1 MA? MA2 -> FALSE FALSE FALSE }T\ -----------------------------------------------------------------------------TESTING ?DO: QD ?DO I LOOP ;T{ 789 789 QD -> }TT{ -9876 -9876 QD -> }TT{ 5 0 QD -> 0 1 2 3 4 }T: QD1 ?DO I 10 +LOOP ;T{ 50 1 QD1 -> 1 11 21 31 41 }TT{ 50 0 QD1 -> 0 10 20 30 40 }T: QD2 ?DO I 3 > IF LEAVE ELSE I THEN LOOP ;T{ 5 -1 QD2 -> -1 0 1 2 3 }T: QD3 ?DO I 1 +LOOP ;T{ 4  4 QD3 -> }TT{ 4  1 QD3 -> 1 2 3 }TT{ 2 -1 QD3 -> -1 0 1 }T: QD4 ?DO I -1 +LOOP ;T{  4 4 QD4 -> }TT{  1 4 QD4 -> 4 3 2 1 }TT{ -1 2 QD4 -> 2 1 0 -1 }T: QD5 ?DO I -10 +LOOP ;T{   1 50 QD5 -> 50 40 30 20 10 }TT{   0 50 QD5 -> 50 40 30 20 10 0 }TT{ -25 10 QD5 -> 10 0 -10 -20 }TVARIABLE ITERSVARIABLE INCRMNT: QD6 ( LIMIT START INCREMENT -- )   INCRMNT !   0 ITERS !   ?DO      1 ITERS +!      I      ITERS @  6 = IF LEAVE THEN      INCRMNT @   +LOOP ITERS @;T{  4  4 -1 QD6 -> 0 }TT{  1  4 -1 QD6 -> 4 3 2 1 4 }TT{  4  1 -1 QD6 -> 1 0 -1 -2 -3 -4 6 }TT{  4  1  0 QD6 -> 1 1 1 1 1 1 6 }TT{  0  0  0 QD6 -> 0 }TT{  1  4  0 QD6 -> 4 4 4 4 4 4 6 }TT{  1  4  1 QD6 -> 4 5 6 7 8 9 6 }TT{  4  1  1 QD6 -> 1 2 3 3 }TT{  4  4  1 QD6 -> 0 }TT{  2 -1 -1 QD6 -> -1 -2 -3 -4 -5 -6 6 }TT{ -1  2 -1 QD6 -> 2 1 0 -1 4 }TT{  2 -1  0 QD6 -> -1 -1 -1 -1 -1 -1 6 }TT{ -1  2  0 QD6 -> 2 2 2 2 2 2 6 }TT{ -1  2  1 QD6 -> 2 3 4 5 6 7 6 }TT{  2 -1  1 QD6 -> -1 0 1 3 }T\ -----------------------------------------------------------------------------TESTING BUFFER:T{ 8 BUFFER: BUF:TEST -> }TT{ BUF:TEST DUP ALIGNED = -> TRUE }TT{ 111 BUF:TEST ! 222 BUF:TEST CELL+ ! -> }TT{ BUF:TEST @ BUF:TEST CELL+ @ -> 111 222 }T\ -----------------------------------------------------------------------------TESTING VALUE TOT{ 111 VALUE VAL1 -999 VALUE VAL2 -> }TT{ VAL1 -> 111 }TT{ VAL2 -> -999 }TT{ 222 TO VAL1 -> }TT{ VAL1 -> 222 }TT{ : VD1 VAL1 ; -> }TT{ VD1 -> 222 }TT{ : VD2 TO VAL2 ; -> }TT{ VAL2 -> -999 }TT{ -333 VD2 -> }TT{ VAL2 -> -333 }TT{ VAL1 -> 222 }TT{ 123 VALUE VAL3 IMMEDIATE VAL3 -> 123 }TT{ : VD3 VAL3 LITERAL ; VD3 -> 123 }T\ -----------------------------------------------------------------------------TESTING CASE OF ENDOF ENDCASE: CS1 CASE 1 OF 111 ENDOF           2 OF 222 ENDOF           3 OF 333 ENDOF           >R 999 R>      ENDCASE;T{ 1 CS1 -> 111 }TT{ 2 CS1 -> 222 }TT{ 3 CS1 -> 333 }TT{ 4 CS1 -> 999 }T\ NESTED CASE'S: CS2 >R CASE -1 OF CASE R@ 1 OF 100 ENDOF                            2 OF 200 ENDOF                           >R -300 R>                    ENDCASE                 ENDOF              -2 OF CASE R@ 1 OF -99  ENDOF                            >R -199 R>                    ENDCASE                 ENDOF                 >R 299 R>         ENDCASE R> DROP;T{ -1 1 CS2 ->  100 }TT{ -1 2 CS2 ->  200 }TT{ -1 3 CS2 -> -300 }TT{ -2 1 CS2 -> -99  }TT{ -2 2 CS2 -> -199 }TT{  0 2 CS2 ->  299 }T\ BOOLEAN SHORT CIRCUITING USING CASE: CS3  ( N1 -- N2 )   CASE 1- FALSE OF 11 ENDOF        1- FALSE OF 22 ENDOF        1- FALSE OF 33 ENDOF        44 SWAP   ENDCASE;T{ 1 CS3 -> 11 }TT{ 2 CS3 -> 22 }TT{ 3 CS3 -> 33 }TT{ 9 CS3 -> 44 }T\ EMPTY CASE STATEMENTS WITH/WITHOUT DEFAULTT{ : CS4 CASE ENDCASE ; 1 CS4 -> }TT{ : CS5 CASE 2 SWAP ENDCASE ; 1 CS5 -> 2 }TT{ : CS6 CASE 1 OF ENDOF 2 ENDCASE ; 1 CS6 -> }TT{ : CS7 CASE 3 OF ENDOF 2 ENDCASE ; 1 CS7 -> 1 }T\ -----------------------------------------------------------------------------TESTING :NONAME RECURSEVARIABLE NN1VARIABLE NN2:NONAME 1234 ; NN1 !:NONAME 9876 ; NN2 !T{ NN1 @ EXECUTE -> 1234 }TT{ NN2 @ EXECUTE -> 9876 }TT{ :NONAME ( N -- 0,1,..N ) DUP IF DUP >R 1- RECURSE R> THEN ;   CONSTANT RN1 -> }TT{ 0 RN1 EXECUTE -> 0 }TT{ 4 RN1 EXECUTE -> 0 1 2 3 4 }T:NONAME  ( N -- N1 )    \ MULTIPLE RECURSES IN ONE DEFINITION   1- DUP   CASE 0 OF EXIT ENDOF        1 OF 11 SWAP RECURSE ENDOF        2 OF 22 SWAP RECURSE ENDOF        3 OF 33 SWAP RECURSE ENDOF        DROP ABS RECURSE EXIT   ENDCASE; CONSTANT RN2T{  1 RN2 EXECUTE -> 0 }TT{  2 RN2 EXECUTE -> 11 0 }TT{  4 RN2 EXECUTE -> 33 22 11 0 }TT{ 25 RN2 EXECUTE -> 33 22 11 0 }T\ -----------------------------------------------------------------------------TESTING C"T{ : CQ1 C" 123" ; -> }TT{ CQ1 COUNT EVALUATE -> 123 }TT{ : CQ2 C" " ; -> }TT{ CQ2 COUNT EVALUATE -> }TT{ : CQ3 C" 2345"COUNT EVALUATE ; CQ3 -> 2345 }T\ -----------------------------------------------------------------------------TESTING COMPILE,:NONAME DUP + ; CONSTANT DUP+T{ : Q DUP+ COMPILE, ; -> }TT{ : AS1 [ Q ] ; -> }TT{ 123 AS1 -> 246 }T\ -----------------------------------------------------------------------------\ CANNOT AUTOMATICALLY TEST SAVE-INPUT AND RESTORE-INPUT FROM A CONSOLE SOURCETESTING SAVE-INPUT AND RESTORE-INPUT WITH A STRING SOURCEVARIABLE SI_INC 0 SI_INC !: SI1   SI_INC @ >IN +!   15 SI_INC !;: S$ S" SAVE-INPUT SI1 RESTORE-INPUT 12345" ;T{ S$ EVALUATE SI_INC @ -> 0 2345 15 }T\ -----------------------------------------------------------------------------TESTING .(CR CR .( OUTPUT FROM .() T{ CR .( YOU SHOULD SEE -9876: ) -9876 . -> }TT{ CR .( AND AGAIN: ).( -9876)CR -> }TCR CR .( ON THE NEXT 2 LINES YOU SHOULD SEE FIRST THEN SECOND MESSAGES:)T{ : DOTP  CR ." SECOND MESSAGE VIA ." [CHAR] " EMIT    \ CHECK .( IS IMMEDIATE     [ CR ] .( FIRST MESSAGE VIA .( ) ; DOTP -> }TCR CRT{ : IMM? BL WORD FIND NIP ; IMM? .( -> 1 }T\ -----------------------------------------------------------------------------TESTING .R AND U.R - HAS TO HANDLE DIFFERENT CELL SIZES\ CREATE SOME LARGE INTEGERS JUST BELOW/ABOVE MAX AND MIN INTSMAX-INT 73 79 */ CONSTANT LI1MIN-INT 71 73 */ CONSTANT LI2LI1 0 <# #S #> NIP CONSTANT LENLI1: (.R&U.R)  ( U1 U2 -- )  \ U1 <= STRING LENGTH, U2 IS REQUIRED INDENTATION   TUCK + >R   LI1 OVER SPACES  . CR R@    LI1 SWAP  .R CR   LI2 OVER SPACES  . CR R@ 1+ LI2 SWAP  .R CR   LI1 OVER SPACES U. CR R@    LI1 SWAP U.R CR   LI2 SWAP SPACES U. CR R>    LI2 SWAP U.R CR;: .R&U.R  ( -- )   CR ." YOU SHOULD SEE LINES DUPLICATED:" CR   ." INDENTED BY 0 SPACES" CR 0      0 (.R&U.R) CR   ." INDENTED BY 0 SPACES" CR LENLI1 0 (.R&U.R) CR \ JUST FITS REQUIRED WIDTH   ." INDENTED BY 5 SPACES" CR LENLI1 5 (.R&U.R) CR;CR CR .( OUTPUT FROM .R AND U.R)T{ .R&U.R -> }T\ -----------------------------------------------------------------------------TESTING PAD ERASE\ MUST HANDLE DIFFERENT SIZE CHARACTERS I.E. 1 CHARS >= 1 84 CONSTANT CHARS/PAD      \ MINIMUM SIZE OF PAD IN CHARSCHARS/PAD CHARS CONSTANT AUS/PAD: CHECKPAD  ( CADDR U CH -- F )  \ F = TRUE IF U CHARS = CH   SWAP 0   ?DO      OVER I CHARS + C@ OVER <>      IF 2DROP UNLOOP FALSE EXIT THEN   LOOP     2DROP TRUE;T{ PAD DROP -> }TT{ 0 INVERT PAD C! -> }TT{ PAD C@ CONSTANT MAXCHAR -> }TT{ PAD CHARS/PAD 2DUP MAXCHAR FILL MAXCHAR CHECKPAD -> TRUE }TT{ PAD CHARS/PAD 2DUP CHARS ERASE 0 CHECKPAD -> TRUE }TT{ PAD CHARS/PAD 2DUP MAXCHAR FILL PAD 0 ERASE MAXCHAR CHECKPAD -> TRUE }TT{ PAD 43 CHARS + 9 CHARS ERASE -> }TT{ PAD 43 MAXCHAR CHECKPAD -> TRUE }TT{ PAD 43 CHARS + 9 0 CHECKPAD -> TRUE }TT{ PAD 52 CHARS + CHARS/PAD 52 - MAXCHAR CHECKPAD -> TRUE }T\ CHECK THAT USE OF WORD AND PICTURED NUMERIC OUTPUT DO NOT CORRUPT PAD\ MINIMUM SIZE OF BUFFERS FOR THESE ARE 33 CHARS AND (2*N)+2 CHARS RESPECTIVELY\ WHERE N IS NUMBER OF BITS PER CELLPAD CHARS/PAD ERASE2 BASE !MAX-UINT MAX-UINT <# #S CHAR 1 DUP HOLD HOLD #> 2DROPDECIMALBL WORD 12345678123456781234567812345678 DROPT{ PAD CHARS/PAD 0 CHECKPAD -> TRUE }T\ -----------------------------------------------------------------------------TESTING PARSET{ CHAR | PARSE 1234| DUP ROT ROT EVALUATE -> 4 1234 }TT{ CHAR ^ PARSE  23 45 ^ DUP ROT ROT EVALUATE -> 7 23 45 }T: PA1 [CHAR] $ PARSE DUP >R PAD SWAP CHARS MOVE PAD R> ;T{ PA1 3456   DUP ROT ROT EVALUATE -> 4 3456 }TT{ CHAR A PARSE A SWAP DROP -> 0 }TT{ CHAR Z PARSE   SWAP DROP -> 0 }TT{ CHAR " PARSE 4567 "DUP ROT ROT EVALUATE -> 5 4567 }T \ -----------------------------------------------------------------------------TESTING PARSE-NAME  (FORTH 2012)\ ADAPTED FROM THE PARSE-NAME RFD TESTST{ PARSE-NAME ABCD  STR1  S= -> TRUE }T        \ NO LEADING SPACEST{ PARSE-NAME      ABCDE STR2 S= -> TRUE }T    \ LEADING SPACES\ TEST EMPTY PARSE AREA, NEW LINES ARE NECESSARYT{ PARSE-NAME  NIP -> 0 }T\ EMPTY PARSE AREA WITH SPACES AFTER PARSE-NAMET{ PARSE-NAME           NIP -> 0 }TT{ : PARSE-NAME-TEST ( "NAME1" "NAME2" -- N )    PARSE-NAME PARSE-NAME S= ; -> }TT{ PARSE-NAME-TEST ABCD ABCD  -> TRUE }TT{ PARSE-NAME-TEST ABCD   ABCD  -> TRUE }T  \ LEADING SPACEST{ PARSE-NAME-TEST ABCDE ABCDF -> FALSE }TT{ PARSE-NAME-TEST ABCDF ABCDE -> FALSE }TT{ PARSE-NAME-TEST ABCDE ABCDE   -> TRUE }T         \ PARSE TO END OF LINET{ PARSE-NAME-TEST ABCDE           ABCDE            -> TRUE }T         \ LEADING AND TRAILING SPACES\ -----------------------------------------------------------------------------TESTING DEFER DEFER@ DEFER! IS ACTION-OF (FORTH 2012)\ ADAPTED FROM THE FORTH 200X RFD TESTST{ DEFER DEFER1 -> }TT{ : MY-DEFER DEFER ; -> }TT{ : IS-DEFER1 IS DEFER1 ; -> }TT{ : ACTION-DEFER1 ACTION-OF DEFER1 ; -> }TT{ : DEF! DEFER! ; -> }TT{ : DEF@ DEFER@ ; -> }TT{ ' * ' DEFER1 DEFER! -> }TT{ 2 3 DEFER1 -> 6 }TT{ ' DEFER1 DEFER@ -> ' * }TT{ ' DEFER1 DEF@ -> ' * }TT{ ACTION-OF DEFER1 -> ' * }TT{ ACTION-DEFER1 -> ' * }TT{ ' + IS DEFER1 -> }TT{ 1 2 DEFER1 -> 3 }TT{ ' DEFER1 DEFER@ -> ' + }TT{ ' DEFER1 DEF@ -> ' + }TT{ ACTION-OF DEFER1 -> ' + }TT{ ACTION-DEFER1 -> ' + }TT{ ' - IS-DEFER1 -> }TT{ 1 2 DEFER1 -> -1 }TT{ ' DEFER1 DEFER@ -> ' - }TT{ ' DEFER1 DEF@ -> ' - }TT{ ACTION-OF DEFER1 -> ' - }TT{ ACTION-DEFER1 -> ' - }TT{ MY-DEFER DEFER2 -> }TT{ ' DUP IS DEFER2 -> }TT{ 1 DEFER2 -> 1 1 }T\ -----------------------------------------------------------------------------TESTING HOLDS  (FORTH 2012): HTEST S" TESTING HOLDS" ;: HTEST2 S" WORKS" ;: HTEST3 S" TESTING HOLDS WORKS 123" ;T{ 0 0 <#  HTEST HOLDS #> HTEST S= -> TRUE }TT{ 123 0 <# #S BL HOLD HTEST2 HOLDS BL HOLD HTEST HOLDS #>   HTEST3 S= -> TRUE }TT{ : HLD HOLDS ; -> }TT{ 0 0 <#  HTEST HLD #> HTEST S= -> TRUE }T\ -----------------------------------------------------------------------------TESTING REFILL SOURCE-ID\ REFILL AND SOURCE-ID FROM THE USER INPUT DEVICE CAN'T BE TESTED FROM A FILE,\ CAN ONLY BE TESTED FROM A STRING VIA EVALUATET{ : RF1  S" REFILL" EVALUATE ; RF1 -> FALSE }TT{ : SID1  S" SOURCE-ID" EVALUATE ; SID1 -> -1 }T\ ------------------------------------------------------------------------------TESTING S\"  (FORTH 2012 COMPILATION MODE)\ EXTENDED THE FORTH 200X RFD TESTS\ NOTE THIS TESTS THE CORE EXT DEFINITION OF S\" WHICH HAS UNEDFINED\ INTERPRETATION SEMANTICS. S\" IN INTERPRETATION MODE IS TESTED IN THE TESTS ON\ THE FILE-ACCESS WORD SETT{ : SSQ1 S\" ABC" S" ABC" S= ; -> }T  \ NO ESCAPEST{ SSQ1 -> TRUE }TT{ : SSQ2 S\" " ; SSQ2 SWAP DROP -> 0 }T    \ EMPTY STRINGT{ : SSQ3 S\" \A\B\E\F\L\M\Q\R\T\V\X0F0\X1FA\XABX\Z\"\\" ; -> }TT{ SSQ3 SWAP DROP          ->  20 }T    \ STRING LENGTHT{ SSQ3 DROP            C@ ->   7 }T    \ \A   BEL  BELLT{ SSQ3 DROP  1 CHARS + C@ ->   8 }T    \ \B   BS   BACKSPACET{ SSQ3 DROP  2 CHARS + C@ ->  27 }T    \ \E   ESC  ESCAPET{ SSQ3 DROP  3 CHARS + C@ ->  12 }T    \ \F   FF   FORM FEEDT{ SSQ3 DROP  4 CHARS + C@ ->  10 }T    \ \L   LF   LINE FEEDT{ SSQ3 DROP  5 CHARS + C@ ->  13 }T    \ \M        CR OF CR/LF PAIRT{ SSQ3 DROP  6 CHARS + C@ ->  10 }T    \           LF OF CR/LF PAIRT{ SSQ3 DROP  7 CHARS + C@ ->  34 }T    \ \Q   "    DOUBLE QUOTET{ SSQ3 DROP  8 CHARS + C@ ->  13 }T    \ \R   CR   CARRIAGE RETURNT{ SSQ3 DROP  9 CHARS + C@ ->   9 }T    \ \T   TAB  HORIZONTAL TABT{ SSQ3 DROP 10 CHARS + C@ ->  11 }T    \ \V   VT   VERTICAL TABT{ SSQ3 DROP 11 CHARS + C@ ->  15 }T    \ \X0F      GIVEN CHART{ SSQ3 DROP 12 CHARS + C@ ->  48 }T    \ 0    0    DIGIT FOLLOW ONT{ SSQ3 DROP 13 CHARS + C@ ->  31 }T    \ \X1F      GIVEN CHART{ SSQ3 DROP 14 CHARS + C@ ->  65 }T    \ A    A    HEX FOLLOW ONT{ SSQ3 DROP 15 CHARS + C@ -> 171 }T    \ \XAB      INSENSITIVE GIVEN CHART{ SSQ3 DROP 16 CHARS + C@ ->  88 }T    \ X    X    NON HEX FOLLOW ONT{ SSQ3 DROP 17 CHARS + C@ ->   0 }T    \ \Z   NUL  NO CHARACTERT{ SSQ3 DROP 18 CHARS + C@ ->  34 }T    \ \"   "    DOUBLE QUOTET{ SSQ3 DROP 19 CHARS + C@ ->  92 }T    \ \\   \    BACK SLASH\ THE ABOVE DOES NOT TEST \N AS THIS IS A SYSTEM DEPENDENT VALUE.\ CHECK IT DISPLAYS A NEW LINECR .( THE NEXT TEST SHOULD DISPLAY:)CR .( ONE LINE...)CR .( ANOTHER LINE)T{ : SSQ4 S\" \NONE LINE...\NANOTHERLINE\N" TYPE ; SSQ4 -> }T\ TEST BARE ESCAPABLE CHARACTERS APPEAR AS THEMSELVEST{ : SSQ5 S\" ABEFLMNQRTVXZ" S" ABEFLMNQRTVXZ" S= ; SSQ5 -> TRUE }TT{ : SSQ6 S\" A\""2DROP 1111 ; SSQ6 -> 1111 }T \ PARSING BEHAVIOURT{ : SSQ7  S\" 111 : SSQ8 S\\\" 222\" EVALUATE ; SSQ8 333" EVALUATE ; -> }TT{ SSQ7 -> 111 222 333 }TT{ : SSQ9  S\" 11 : SSQ10 S\\\" \\X32\\X32\" EVALUATE ; SSQ10 33" EVALUATE ; -> }TT{ SSQ9 -> 11 22 33 }T\ -----------------------------------------------------------------------------CORE-EXT-ERRORS SET-ERROR-COUNTCR .( END OF CORE EXTENSION WORD TESTS) CR