CR CR SOURCE TYPE ( PRELIMINARY TEST ) CRSOURCE ( THESE LINES TEST SOURCE, TYPE, CR AND PARENTHETIC COMMENTS ) TYPE CR( THE NEXT LINE OF OUTPUT SHOULD BE BLANK TO TEST CR ) SOURCE TYPE CR CR( IT IS NOW ASSUMED THAT SOURCE, TYPE, CR AND COMMENTS WORK. SOURCE AND      )( TYPE WILL BE USED TO REPORT TEST PASSES UNTIL SOMETHING BETTER CAN BE      )( DEFINED TO REPORT ERRORS. UNTIL THEN REPORTING FAILURES WILL DEPEND ON THE )( SYSTEM UNDER TEST AND WILL USUALLY BE VIA REPORTING AN UNRECOGNISED WORD   )( OR POSSIBLY THE SYSTEM CRASHING. TESTS WILL BE NUMBERED BY #N FROM NOW ON  )( TO ASSIST FAULT FINDING. TEST SUCCESSES WILL BE INDICATED BY               )( 'PASS: #N ...' AND FAILURES BY 'ERROR: #N ...'                             )( INITIAL TESTS OF >IN +! AND 1+ )( CHECK THAT N >IN +! ACTS AS AN INTERPRETIVE IF, WHERE N >= 0 )( PASS #1: TESTING 0 >IN +! ) 0 >IN +! SOURCE TYPE CR( PASS #2: TESTING 1 >IN +! ) 1 >IN +! XSOURCE TYPE CR( PASS #3: TESTING 1+ ) 1 1+ >IN +! XXSOURCE TYPE CR( TEST RESULTS CAN NOW BE REPORTED USING THE >IN +! TRICK TO SKIP )( 1 OR MORE CHARACTERS )( THE VALUE OF BASE IS UNKNOWN SO IT IS NOT SAFE TO USE DIGITS > 1, THEREFORE )( IT WILL BE SET IT TO BINARY AND THEN DECIMAL, THIS ALSO TESTS @ AND ! )( PASS #4: TESTING @ ! BASE ) 0 1+ 1+ BASE ! BASE @ >IN +! XXSOURCE TYPE CR( SET BASE TO DECIMAL ) 1010 BASE !( PASS #5: TESTING DECIMAL BASE ) BASE @ >IN +! XXXXXXXXXXSOURCE TYPE CR( NOW IN DECIMAL MODE AND DIGITS >1 CAN BE USED )( A BETTER ERROR REPORTING WORD IS NEEDED, MUCH LIKE .( WHICH CAN'T  )( BE USED AS IT IS IN THE CORE EXTENSION WORD SET, SIMILARLY PARSE CAN'T BE )( USED EITHER, ONLY WORD IS AVAILABLE TO PARSE A MESSAGE AND MUST BE USED   )( IN A COLON DEFINITION. THEREFORE A SIMPLE COLON DEFINITION IS TESTED NEXT )( PASS #6: TESTING : ; ) : .SRC SOURCE TYPE CR ; 6 >IN +! XXXXXX.SRC( PASS #7: TESTING NUMBER INPUT ) 19 >IN +! XXXXXXXXXXXXXXXXXXX.SRC( VARIABLE IS NOW TESTED AS ONE WILL BE USED INSTEAD OF DROP E.G. Y ! )( PASS #8: TESTING VARIABLE ) VARIABLE Y 2 Y ! Y @ >IN +! XX.SRC: MSG 41 WORD COUNT ;  ( 41 IS THE ASCII CODE FOR RIGHT PARENTHESIS )( THE NEXT TESTS MSG LEAVES 2 ITEMS ON THE DATA STACK )( PASS #9: TESTING WORD COUNT ) 5 MSG ABCDEF) Y ! Y ! >IN +! XXXXX.SRC( PASS #10: TESTING WORD COUNT ) MSG AB) >IN +! XXY ! .SRC( FOR REPORTING SUCCESS .MSG( IS NOW DEFINED ): .MSG( MSG TYPE ; .MSG( PASS #11: TESTING WORD COUNT .MSG) CR( TO DEFINE AN ERROR REPORTING WORD, = 2* AND WILL BE NEEDED, TEST THEM FIRST )( THIS ASSUMES 2'S COMPLEMENT ARITHMETIC )1 1 = 1+ 1+ >IN +! X.MSG( PASS #12: TESTING = RETURNS ALL 1'S FOR TRUE) CR1 0 = 1+ >IN +! X.MSG( PASS #13: TESTING = RETURNS 0 FOR FALSE) CR1 1 = -1 = 1+ 1+ >IN +! X.MSG( PASS #14: TESTING -1 INTERPRETED CORRECTLY) CR1 2* >IN +! XX.MSG( PASS #15: TESTING 2*) CR-1 2* 1+ 1+ 1+ >IN +! X.MSG( PASS #16: TESTING 2*) CR-1 -1 AND 1+ 1+ >IN +! X.MSG( PASS #17: TESTING AND) CR-1  0 AND 1+ >IN +! X.MSG( PASS #18: TESTING AND) CR6  -1 AND >IN +! XXXXXX.MSG( PASS #19: TESTING AND) CR( DEFINE ~ TO USE AS A 'TO END OF LINE' COMMENT. \ CANNOT BE USED AS IT A )( CORE EXTENSION WORD ): ~  ( -- )  SOURCE >IN ! Y ! ;( RATHER THAN RELYING ON A PASS MESSAGE TEST WORDS CAN NOW BE DEFINED TO )( REPORT ERRORS IN THE EVENT OF A FAILURE. FOR CONVENIENCE WORDS ?T~ AND )( ?F~ ARE DEFINED TOGETHER WITH A HELPER ?~~ TO TEST FOR TRUE AND FALSE  )( USAGE IS: <TEST> ?T~ ERROR #N: <MESSAGE>                               )( SUCCESS MAKES >IN INDEX THE ~ IN ?T~ OR ?F~ TO SKIP THE ERROR MESSAGE. )( HENCE IT IS ESSENTIAL THERE IS ONLY 1 SPACE BETWEEN ?T~ AND ERROR      ): ?~~  ( -1 | 0 -- )  2* >IN +! ;: ?F~ ( F -- )   0 = ?~~ ;: ?T~ ( F -- )  -1 = ?~~ ;( ERRORS WILL BE COUNTED )VARIABLE #ERRS 0 #ERRS !: ERROR  1 #ERRS +! -6 >IN +! .MSG( CR ;: PASS  -1 #ERRS +! 1 >IN +! ERROR ;  ~ PASS IS DEFINED SOLELY TO TEST ERROR-1 ?F~ PASS #20: TESTING ?F~ ?~~ PASS ERROR-1 ?T~ ERROR #1: TESTING ?T~ ?~~ ~0  0 = 0= ?F~ ERROR #2: TESTING 0=1  0 = 0= ?T~ ERROR #3: TESTING 0=-1 0 = 0= ?T~ ERROR #4: TESTING 0=0  0 = ?T~ ERROR #5: TESTING =0  1 = ?F~ ERROR #6: TESTING =1  0 = ?F~ ERROR #7: TESTING =-1 1 = ?F~ ERROR #8: TESTING =1 -1 = ?F~ ERROR #9: TESTING =-1 0< ?T~ ERROR #10: TESTING 0<0  0< ?F~ ERROR #11: TESTING 0<1  0< ?F~ ERROR #12: TESTING 0< DEPTH 1+ DEPTH = ?~~ ERROR #13: TESTING DEPTH ~ UP TO NOW WHETHER THE DATA STACK WAS EMPTY OR NOT HASN'T MATTERED AS ~ LONG AS IT DIDN'T OVERFLOW. NOW IT WILL BE EMPTIED - ALSO ~ REMOVING ANY UNREPORTED UNDERFLOW DEPTH 0< 0= 1+ >IN +! ~ 0 0 >IN ! REMOVE ANY UNDERFLOW DEPTH 0= 1+ >IN +! ~ Y !  0 >IN ! EMPTY THE STACK DEPTH 0= ?T~ ERROR #14: DATA STACK NOT EMPTIED  4 -5 SWAP 4 = SWAP -5 = = ?T~ ERROR #15: TESTING SWAP 111 222 333 444 DEPTH 4 = ?T~ ERROR #16: TESTING DEPTH 444 = SWAP 333 = = DEPTH 3 = = ?T~ ERROR #17: TESTING SWAP DEPTH 222 = SWAP 111 = = DEPTH 1 = = ?T~ ERROR #18: TESTING SWAP DEPTH DEPTH 0= ?T~ ERROR #19: TESTING DEPTH = 0~ FROM NOW ON THE STACK IS EXPECTED TO BE EMPTY AFTER A TEST SO~ ?~ WILL BE DEFINED TO INCLUDE A CHECK ON THE STACK DEPTH. NOTE~ THAT ?~~ WAS DEFINED AND USED EARLIER INSTEAD OF ?~ TO AVOID~ (IRRITATING) REDEFINITION MESSAGES THAT MANY SYSTEMS DISPLAY HAD~ ?~ SIMPLY BEEN REDEFINED: ?~  ( -1 | 0 -- )  DEPTH 1 = AND ?~~ ; ~ -1 TEST SUCCESS, 0 TEST FAILURE123 -1 ?~ PASS #21: TESTING ?~Y !   ~ EQUIVALENT TO DROP~ TESTING THE REMAINING CORE WORDS USED IN THE HAYES TESTER, WITH THE ABOVE~ DEFINITIONS THESE ARE STRAIGHTFORWARD1 DROP DEPTH 0= ?~ ERROR #20: TESTING DROP123 DUP  = ?~ ERROR #21: TESTING DUP123 ?DUP = ?~ ERROR #22: TESTING ?DUP0  ?DUP 0= ?~ ERROR #23: TESTING ?DUP123  111  + 234  = ?~ ERROR #24: TESTING +123  -111 + 12   = ?~ ERROR #25: TESTING +-123 111  + -12  = ?~ ERROR #26: TESTING +-123 -111 + -234 = ?~ ERROR #27: TESTING +-1 NEGATE 1 = ?~ ERROR #28: TESTING NEGATE0  NEGATE 0=  ?~ ERROR #29: TESTING NEGATE987 NEGATE -987 = ?~ ERROR #30: TESTING NEGATEHERE DEPTH SWAP DROP 1 = ?~ ERROR #31: TESTING HERECREATE TST1 HERE TST1 = ?~ ERROR #32: TESTING CREATE HERE16  ALLOT HERE TST1 NEGATE + 16 = ?~ ERROR #33: TESTING ALLOT-16 ALLOT HERE TST1 = ?~ ERROR #34: TESTING ALLOT0 CELLS 0= ?~ ERROR #35: TESTING CELLS1 CELLS ALLOT HERE TST1 NEGATE + VARIABLE CSZ CSZ !CSZ @ 0= 0= ?~ ERROR #36: TESTING CELLS3 CELLS CSZ @ DUP 2* + = ?~ ERROR #37: TESTING CELLS-3 CELLS CSZ @ DUP 2* + + 0= ?~ ERROR #38: TESTING CELLS: TST2  ( F -- N )  DUP IF 1+ THEN ;0 TST2 0=  ?~ ERROR #39: TESTING IF THEN1 TST2 2 = ?~ ERROR #40: TESTING IF THEN: TST3  ( N1 -- N2 )  IF 123 ELSE 234 THEN ;0 TST3 234 = ?~ ERROR #41: TESTING IF ELSE THEN1 TST3 123 = ?~ ERROR #42: TESTING IF ELSE THEN: TST4  ( -- N )  0 5 0 DO 1+ LOOP ;TST4 5 = ?~ ERROR #43: TESTING DO LOOP: TST5  ( -- N )  0 10 0 DO I + LOOP ;TST5 45 = ?~ ERROR #44: TESTING I: TST6  ( -- N )  0 10 0 DO DUP 5 = IF LEAVE ELSE 1+ THEN LOOP ;TST6 5 = ?~ ERROR #45: TESTING LEAVE: TST7  ( -- N1 N2 ) 123 >R 234 R> ;TST7 NEGATE + 111 = ?~ ERROR #46: TESTING >R R>: TST8  ( -- CH )  [CHAR] A ;TST8 65 = ?~ ERROR #47: TESTING [CHAR]: TST9  ( -- )  [CHAR] S [CHAR] S [CHAR] A [CHAR] P 4 0 DO EMIT LOOP ;TST9 .MSG(  #22: TESTING EMIT) CR: TST10  ( -- )  S" PASS #23: TESTING S" TYPE [CHAR] " EMIT CR ; TST10~ THE HAYES CORE TEST CORE.FR USES CONSTANT BEFORE IT IS TESTED THEREFORE~ WE TEST CONSTANT HERE1234 CONSTANT CTESTCTEST 1234 = ?~ ERROR #48: TESTING CONSTANT~ THE HAYES TESTER USES SOME WORDS FROM THE CORE EXTENSION WORD SET~ THESE WILL BE CONDITIONALLY DEFINED FOLLOWING DEFINITION OF A~ WORD CALLED ?DEFINED TO DETERMINE WHETHER THESE ARE ALREADY DEFINEDVARIABLE TIMM1 0 TIMM1 !: TIMM2  123 TIMM1 ! ; IMMEDIATE: TIMM3 TIMM2 ; TIMM1 @ 123 = ?~ ERROR #49: TESTING IMMEDIATE: ?DEFINED  ( "NAME" -- 0 | -1 )  32 WORD FIND SWAP DROP 0= 0= ;?DEFINED SWAP ?~ ERROR #50: TESTING FIND ?DEFINED?DEFINED <<NO-SUCH-WORD-HOPEFULLY>> 0= ?~ ERROR #51 TESTING FIND ?DEFINED?DEFINED \ ?~ : \ ~ ; IMMEDIATE \ ERROR #52: TESTING \: TIMM4  \ ERROR #53: TESTING \ IS IMMEDIATE;~ TRUE AND FALSE ARE DEFINED AS COLON DEFINITIONS AS THEY HAVE BEEN USED~ MORE THAN CONSTANT ABOVE?DEFINED TRUE  ?~ : TRUE 1 NEGATE ;?DEFINED FALSE ?~ : FALSE 0 ;?DEFINED HEX   ?~ : HEX 16 BASE ! ;TRUE -1 = ?~ ERROR #54: TESTING TRUEFALSE 0=  ?~ ERROR #55: TESTING FALSE10 HEX 0A = ?~ ERROR #56: TESTING HEXAB 0A BASE ! 171 = ?~ ERROR #57: TESTING HEX NUMBER~ DELETE THE ~ ON THE NEXT 2 LINES TO CHECK THE FINAL ERROR REPORT~ ERROR #998: TESTING A DELIBERATE FAILURE~ ERROR #999: TESTING A DELIBERATE FAILURE~ DESCRIBE THE MESSAGES THAT SHOULD BE SEEN. THE PREVIOUSLY DEFINED .MSG(~ CAN BE USED FOR TEXT MESSAGESCR .MSG( RESULTS: ) CRCR .MSG( PASS MESSAGES #1 TO #23 SHOULD BE DISPLAYED ABOVE)CR .MSG( AND NO ERROR MESSAGES) CR~ FINALLY DISPLAY A MESSAGE GIVING THE NUMBER OF TESTS THAT FAILED.~ THIS IS COMPLICATED BY THE FACT THAT UNTESTED WORDS INCLUDING .( ." AND .~ CANNOT BE USED. ALSO MORE COLON DEFINITIONS SHOULDN'T BE DEFINED THAN ARE~ NEEDED. TO DISPLAY A NUMBER, NOTE THAT THE NUMBER OF ERRORS WILL HAVE~ ONE OR TWO DIGITS AT MOST AND AN INTERPRETIVE LOOP CAN BE USED TO~ DISPLAY THOSE.CR0 #ERRS @~ LOOP TO CALCULATE THE 10'S DIGIT (IF ANY)DUP NEGATE 9 + 0< NEGATE >IN +! ( -10 + SWAP 1+ SWAP 0 >IN ! )~ DISPLAY THE ERROR COUNTSWAP ?DUP 0= 1+ >IN +! ( 48 + EMIT ( ) 48 + EMIT.MSG(  TEST) #ERRS @ 1 = 1+ >IN +! ~ .MSG( S).MSG(  FAILED OUT OF 57 ADDITIONAL TESTS) CRCR CR .MSG( --- END OF PRELIMINARY TESTS --- ) CR