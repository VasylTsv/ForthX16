\ ADDITIONAL TESTS ON THE THE ANS FORTH CORE WORD SET\ THIS PROGRAM WAS WRITTEN BY GERRY JACKSON IN 2007, WITH CONTRIBUTIONS FROM\ OTHERS WHERE INDICATED, AND IS IN THE PUBLIC DOMAIN - IT CAN BE DISTRIBUTED\ AND/OR MODIFIED IN ANY WAY BUT PLEASE RETAIN THIS NOTICE.\ THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL,\ BUT WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF\ MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.\ THE TESTS ARE NOT CLAIMED TO BE COMPREHENSIVE OR CORRECT \ ------------------------------------------------------------------------------\ THE TESTS ARE BASED ON JOHN HAYES TEST PROGRAM FOR THE CORE WORD SET\\ THIS FILE PROVIDES SOME MORE TESTS ON CORE WORDS WHERE THE ORIGINAL HAYES\ TESTS ARE THOUGHT TO BE INCOMPLETE\\ WORDS TESTED IN THIS FILE ARE:\     DO I +LOOP RECURSE ELSE >IN IMMEDIATE FIND IF...BEGIN...REPEAT ALLOT DOES>\ AND\     PARSING BEHAVIOUR\     NUMBER PREFIXES # $ % AND 'A' CHARACTER INPUT\     DEFINITION NAMES\ ------------------------------------------------------------------------------\ ASSUMPTIONS AND DEPENDENCIES:\     - TESTER.FR OR TTESTER.FS HAS BEEN LOADED PRIOR TO THIS FILE\     - CORE.FR HAS BEEN LOADED SO THAT CONSTANTS <TRUE> MAX-INT, MIN-INT AND\       MAX-UINT ARE DEFINED\ ------------------------------------------------------------------------------DECIMALTESTING DO +LOOP WITH RUN-TIME INCREMENT, NEGATIVE INCREMENT, INFINITE LOOP\ CONTRIBUTED BY REINHOLD STRAUBVARIABLE ITERATIONSVARIABLE INCREMENT: GD7 ( LIMIT START INCREMENT -- )   INCREMENT !   0 ITERATIONS !   DO      1 ITERATIONS +!      I      ITERATIONS @  6 = IF LEAVE THEN      INCREMENT @   +LOOP ITERATIONS @;T{  4  4 -1 GD7 -> 4 1 }TT{  1  4 -1 GD7 -> 4 3 2 1 4 }TT{  4  1 -1 GD7 -> 1 0 -1 -2 -3 -4 6 }TT{  4  1  0 GD7 -> 1 1 1 1 1 1 6 }TT{  0  0  0 GD7 -> 0 0 0 0 0 0 6 }TT{  1  4  0 GD7 -> 4 4 4 4 4 4 6 }TT{  1  4  1 GD7 -> 4 5 6 7 8 9 6 }TT{  4  1  1 GD7 -> 1 2 3 3 }TT{  4  4  1 GD7 -> 4 5 6 7 8 9 6 }TT{  2 -1 -1 GD7 -> -1 -2 -3 -4 -5 -6 6 }TT{ -1  2 -1 GD7 -> 2 1 0 -1 4 }TT{  2 -1  0 GD7 -> -1 -1 -1 -1 -1 -1 6 }TT{ -1  2  0 GD7 -> 2 2 2 2 2 2 6 }TT{ -1  2  1 GD7 -> 2 3 4 5 6 7 6 }TT{  2 -1  1 GD7 -> -1 0 1 3 }TT{ -20 30 -10 GD7 -> 30 20 10 0 -10 -20 6 }TT{ -20 31 -10 GD7 -> 31 21 11 1 -9 -19 6 }TT{ -20 29 -10 GD7 -> 29 19 9 -1 -11 5 }T\ ------------------------------------------------------------------------------TESTING DO +LOOP WITH LARGE AND SMALL INCREMENTS\ CONTRIBUTED BY ANDREW HALEYMAX-UINT 8 RSHIFT 1+ CONSTANT USTEPUSTEP NEGATE CONSTANT -USTEPMAX-INT 7 RSHIFT 1+ CONSTANT STEPSTEP NEGATE CONSTANT -STEPVARIABLE BUMPT{ : GD8 BUMP ! DO 1+ BUMP @ +LOOP ; -> }TT{ 0 MAX-UINT 0 USTEP GD8 -> 256 }TT{ 0 0 MAX-UINT -USTEP GD8 -> 256 }TT{ 0 MAX-INT MIN-INT STEP GD8 -> 256 }TT{ 0 MIN-INT MAX-INT -STEP GD8 -> 256 }T\ TWO'S COMPLEMENT ARITHMETIC, WRAPS AROUND MODULO WORDSIZE\ ONLY TESTED IF THE FORTH SYSTEM DOES WRAP AROUND, USE OF CONDITIONAL\ COMPILATION DELIBERATELY AVOIDEDMAX-INT 1+ MIN-INT = CONSTANT +WRAP?MIN-INT 1- MAX-INT = CONSTANT -WRAP?MAX-UINT 1+ 0=       CONSTANT +UWRAP?0 1- MAX-UINT =      CONSTANT -UWRAP?: GD9  ( N LIMIT START STEP F RESULT -- )   >R IF GD8 ELSE 2DROP 2DROP R@ THEN -> R> }T;T{ 0 0 0  USTEP +UWRAP? 256 GD9T{ 0 0 0 -USTEP -UWRAP?   1 GD9T{ 0 MIN-INT MAX-INT  STEP +WRAP? 1 GD9T{ 0 MAX-INT MIN-INT -STEP -WRAP? 1 GD9\ ------------------------------------------------------------------------------TESTING DO +LOOP WITH MAXIMUM AND MINIMUM INCREMENTS: (-MI) MAX-INT DUP NEGATE + 0= IF MAX-INT NEGATE ELSE -32767 THEN ;(-MI) CONSTANT -MAX-INTT{ 0 1 0 MAX-INT GD8  -> 1 }TT{ 0 -MAX-INT NEGATE -MAX-INT OVER GD8  -> 2 }TT{ 0 MAX-INT  0 MAX-INT GD8  -> 1 }TT{ 0 MAX-INT  1 MAX-INT GD8  -> 1 }TT{ 0 MAX-INT -1 MAX-INT GD8  -> 2 }TT{ 0 MAX-INT DUP 1- MAX-INT GD8  -> 1 }TT{ 0 MIN-INT 1+   0 MIN-INT GD8  -> 1 }TT{ 0 MIN-INT 1+  -1 MIN-INT GD8  -> 1 }TT{ 0 MIN-INT 1+   1 MIN-INT GD8  -> 2 }TT{ 0 MIN-INT 1+ DUP MIN-INT GD8  -> 1 }T\ ------------------------------------------------------------------------------\ TESTING +LOOP SETTING I TO AN ARBITRARY VALUE\ THE SPECIFICATION FOR +LOOP PERMITS THE LOOP INDEX I TO BE SET TO ANY VALUE\ INCLUDING A VALUE OUTSIDE THE RANGE GIVEN TO THE CORRESPONDING  DO.\ SET-I IS A HELPER TO SET I IN A DO ... +LOOP TO A GIVEN VALUE\ N2 IS THE VALUE OF I IN A DO ... +LOOP\ N3 IS A TEST VALUE\ IF N2=N3 THEN RETURN N1-N2 ELSE RETURN 1: SET-I  ( N1 N2 N3 -- N1-N2 | 1 )    OVER = IF - ELSE 2DROP 1 THEN;: -SET-I ( N1 N2 N3 -- N1-N2 | -1 )   SET-I DUP 1 = IF NEGATE THEN;: PL1 20 1 DO I 18 I 3 SET-I +LOOP ;T{ PL1 -> 1 2 3 18 19 }T: PL2 20 1 DO I 20 I 2 SET-I +LOOP ;T{ PL2 -> 1 2 }T: PL3 20 5 DO I 19 I 2 SET-I DUP 1 = IF DROP 0 I 6 SET-I THEN +LOOP ;T{ PL3 -> 5 6 0 1 2 19 }T: PL4 20 1 DO I MAX-INT I 4 SET-I +LOOP ;T{ PL4 -> 1 2 3 4 }T: PL5 -20 -1 DO I -19 I -3 -SET-I +LOOP ;T{ PL5 -> -1 -2 -3 -19 -20 }T: PL6 -20 -1 DO I -21 I -4 -SET-I +LOOP ;T{ PL6 -> -1 -2 -3 -4 }T: PL7 -20 -1 DO I MIN-INT I -5 -SET-I +LOOP ;T{ PL7 -> -1 -2 -3 -4 -5 }T: PL8 -20 -5 DO I -20 I -2 -SET-I DUP -1 = IF DROP 0 I -6 -SET-I THEN +LOOP ;T{ PL8 -> -5 -6 0 -1 -2 -20 }T\ ------------------------------------------------------------------------------TESTING MULTIPLE RECURSES IN ONE COLON DEFINITION: ACK ( M N -- U )    \ ACKERMANN FUNCTION, FROM ROSETTA CODE   OVER 0= IF  NIP 1+ EXIT  THEN       \ ACK(0, N) = N+1   SWAP 1- SWAP                        ( -- M-1 N )   DUP  0= IF  1+  RECURSE EXIT  THEN  \ ACK(M, 0) = ACK(M-1, 1)   1- OVER 1+ SWAP RECURSE RECURSE     \ ACK(M, N) = ACK(M-1, ACK(M,N-1));T{ 0 0 ACK ->  1 }TT{ 3 0 ACK ->  5 }TT{ 2 4 ACK -> 11 }T\ ------------------------------------------------------------------------------TESTING MULTIPLE ELSE'S IN AN IF STATEMENT\ DISCUSSED ON COMP.LANG.FORTH AND ACCEPTED AS VALID ANS FORTH: MELSE IF 1 ELSE 2 ELSE 3 ELSE 4 ELSE 5 THEN ;T{ 0 MELSE -> 2 4 }TT{ -1 MELSE -> 1 3 5 }T\ ------------------------------------------------------------------------------TESTING MANIPULATION OF >IN IN INTERPRETER MODET{ 12345 DEPTH OVER 9 < 34 AND + 3 + >IN ! -> 12345 2345 345 45 5 }TT{ 14145 8115 ?DUP 0= 34 AND >IN +! TUCK MOD 14 >IN ! GCD CALCULATION -> 15 }T\ ------------------------------------------------------------------------------TESTING IMMEDIATE WITH CONSTANT  VARIABLE AND CREATE [ ... DOES> ]T{ 123 CONSTANT IW1 IMMEDIATE IW1 -> 123 }TT{ : IW2 IW1 LITERAL ; IW2 -> 123 }TT{ VARIABLE IW3 IMMEDIATE 234 IW3 ! IW3 @ -> 234 }TT{ : IW4 IW3 [ @ ] LITERAL ; IW4 -> 234 }TT{ :NONAME [ 345 ] IW3 [ ! ] ; DROP IW3 @ -> 345 }TT{ CREATE IW5 456 , IMMEDIATE -> }TT{ :NONAME IW5 [ @ IW3 ! ] ; DROP IW3 @ -> 456 }TT{ : IW6 CREATE , IMMEDIATE DOES> @ 1+ ; -> }TT{ 111 IW6 IW7 IW7 -> 112 }TT{ : IW8 IW7 LITERAL 1+ ; IW8 -> 113 }TT{ : IW9 CREATE , DOES> @ 2 + IMMEDIATE ; -> }T: FIND-IW BL WORD FIND NIP ;  ( -- 0 | 1 | -1 )T{ 222 IW9 IW10 FIND-IW IW10 -> -1 }T   \ IW10 IS NOT IMMEDIATET{ IW10 FIND-IW IW10 -> 224 1 }T        \ IW10 BECOMES IMMEDIATE\ ------------------------------------------------------------------------------TESTING THAT IMMEDIATE DOESN'T TOGGLE A FLAGVARIABLE IT1 0 IT1 !: IT2 1234 IT1 ! ; IMMEDIATE IMMEDIATET{ : IT3 IT2 ; IT1 @ -> 1234 }T\ ------------------------------------------------------------------------------TESTING PARSING BEHAVIOUR OF S" ." AND (\ WHICH SHOULD PARSE TO JUST BEYOND THE TERMINATING CHARACTER NO SPACE NEEDEDT{ : GC5 S" A STRING"2DROP ; GC5 -> }TT{ ( A COMMENT)1234 -> 1234 }TT{ : PB1 CR ." YOU SHOULD SEE 2345: "." 2345"( A COMMENT) CR ; PB1 -> }T \ ------------------------------------------------------------------------------TESTING NUMBER PREFIXES # $ % AND 'C' CHARACTER INPUT\ ADAPTED FROM THE FORTH 200X DRAFT 14.5 DOCUMENTVARIABLE OLD-BASEDECIMAL BASE @ OLD-BASE !T{ #1289 -> 1289 }TT{ #-1289 -> -1289 }TT{ $12EF -> 4847 }TT{ $-12EF -> -4847 }TT{ %10010110 -> 150 }TT{ %-10010110 -> -150 }T\ T{ 'Z' -> 122 }TT{ 'Z' -> 90 }T\ CHECK BASE IS UNCHANGEDT{ BASE @ OLD-BASE @ = -> <TRUE> }T\ REPEAT IN HEX MODE16 OLD-BASE ! 16 BASE !T{ #1289 -> 509 }TT{ #-1289 -> -509 }TT{ $12EF -> 12EF }TT{ $-12EF -> -12EF }TT{ %10010110 -> 96 }TT{ %-10010110 -> -96 }T\ T{ 'Z' -> 7A }TT{ 'Z' -> 5A }T\ CHECK BASE IS UNCHANGEDT{ BASE @ OLD-BASE @ = -> <TRUE> }T   \ 2DECIMAL\ CHECK NUMBER PREFIXES IN COMPILE MODET{ : NMP  #8327 $-2CBE %011010111 ''' ; NMP -> 8327 -11454 215 39 }T\ ------------------------------------------------------------------------------TESTING DEFINITION NAMES\ SHOULD SUPPORT {1..31} GRAPHICAL CHARACTERS: !"#$%&'()*+,-./0123456789:;<=>? 1 ;T{ !"#$%&'()*+,-./0123456789:;<=>? -> 1 }T: @ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^ 2 ;T{ @ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^ -> 2 }T: _`ABCDEFGHIJKLMNOPQRSTUVWXYZ{|} 3 ;T{ _`ABCDEFGHIJKLMNOPQRSTUVWXYZ{|} -> 3 }T: _`ABCDEFGHIJKLMNOPQRSTUVWXYZ{|~ 4 ;     \ LAST CHARACTER DIFFERENTT{ _`ABCDEFGHIJKLMNOPQRSTUVWXYZ{|~ -> 4 }TT{ _`ABCDEFGHIJKLMNOPQRSTUVWXYZ{|} -> 3 }T\ ------------------------------------------------------------------------------TESTING FIND WITH A ZERO LENGTH STRING AND A NON-EXISTENT WORDCREATE EMPTYSTRING 0 C,: EMPTYSTRING-FIND-CHECK ( C-ADDR 0 | XT 1 | XT -1 -- T|F )    DUP IF ." FIND RETURNS A TRUE VALUE FOR AN EMPTY STRING!" CR THEN    0= SWAP EMPTYSTRING = = ;T{ EMPTYSTRING FIND EMPTYSTRING-FIND-CHECK -> <TRUE> }TCREATE NON-EXISTENT-WORD   \ SAME AS IN EXCEPTIONTEST.FTH       15 C, CHAR $ C, CHAR $ C, CHAR Q C, CHAR W C, CHAR E C, CHAR Q C,   CHAR W C, CHAR E C, CHAR Q C, CHAR W C, CHAR E C, CHAR R C, CHAR T C,   CHAR $ C, CHAR $ C,T{ NON-EXISTENT-WORD FIND -> NON-EXISTENT-WORD 0 }T\ ------------------------------------------------------------------------------TESTING IF ... BEGIN ... REPEAT (UNSTRUCTURED)T{ : UNS1 DUP 0 > IF 9 SWAP BEGIN 1+ DUP 3 > IF EXIT THEN REPEAT ; -> }TT{ -6 UNS1 -> -6 }TT{  1 UNS1 -> 9 4 }T\ ------------------------------------------------------------------------------TESTING DOES> DOESN'T CAUSE A PROBLEM WITH A CREATED ADDRESS: MAKE-2CONST DOES> 2@ ;T{ CREATE 2K 3 , 2K , MAKE-2CONST 2K -> ' 2K >BODY 3 }T\ ------------------------------------------------------------------------------TESTING ALLOT ( N -- ) WHERE N <= 0T{ HERE 5 ALLOT -5 ALLOT HERE = -> <TRUE> }TT{ HERE 0 ALLOT HERE = -> <TRUE> }T \ ------------------------------------------------------------------------------CR .( END OF ADDITIONAL CORE TESTS) CR